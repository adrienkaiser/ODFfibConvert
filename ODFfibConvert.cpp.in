/*
./ODFfibConvert --ODFfib /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/dwi-00.src.gz.odf8.f5rec.qbi.sh8.0.006.fib.gz
./ODFfibConvert --ODFitk /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/odf.nrrd --mask /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/maskDSI.nii.gz --fa /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/fa.nrrd
*/

/* std classes */
#include <vector>
#include <fstream>
#include <iostream>

#include <zlib.h>

/* ITK classes */
#include <itkImage.h>
#include <itkImageBase.h> // for SizeType and SpacingType without having to declare an ImageType
#include <itkImageFileReader.h>
#include <itkImageFileWriter.h>
#include <itkVectorImage.h>
#include <itksys/SystemTools.hxx>

/* DSIstudio header */
#include <libs/mat_file.hpp>
#include <libs/utility/prog_interface.cpp>

/* Homemade classes */
#include "ODFfibConvertCLP.h" //generated when ccmake
#include "ODFReconstructor.h" // Comes from COST, modified to have ODFType = float instead of double and comment all std::cout

unsigned int NbDirs = 642; // Icosahedron tesselation (subdivision of the whole sphere) in DSI studio
unsigned int NbFaces = 1280; // faces resulting from the tesselation
const unsigned int ODFBlockSize = 20000; // DSIstudio/libs/dsi/odf_process.hpp:60
std::string datFile = "${CMAKE_CURRENT_SOURCE_DIR}/ODFVertices.dat";
std::string FacesFile = "${CMAKE_CURRENT_SOURCE_DIR}/ODFFaces.dat";

  /////////////////////////////////////////
 //            ITK -> FIB               //
/////////////////////////////////////////

template< class T > T* GetArrayFromFile( std::string filename, bool SkipFirstLine ) // SkipFirstLine needed for vertices file ( = datFile -> first line = nb of vertices)
{
  std::ifstream InfileStream (filename.c_str() , std::ios::in); // open in reading
  if(! InfileStream) // error while opening
  {
    return NULL;
  }

  // Get data in a 2 dim vector
  std::vector< std::vector< T > > Vertices;
  Vertices.resize(3);

  std::string line;
  T x, y, z;

  if( SkipFirstLine ) // void read to avoid reading the first line as triple
  {
    std::getline( InfileStream, line );
  }

  while( std::getline( InfileStream, line ) ) 
  {
    std::stringstream linestr(line);
    linestr >> x >> y >> z;

    Vertices[0].push_back(x);
    Vertices[1].push_back(y);
    Vertices[2].push_back(z);
  }

  InfileStream.close();

  // Write data in a 1 dim array
  T* data = new T [ 3 * Vertices[0].size() ] ; // delete after function call in writeFib()

  for( int i = 0 ; i < 3 ; i++ )
  {
    for( int j = 0 ; j < Vertices[0].size() ; j++ )
    {
      data[ i*Vertices[0].size() + j ] = Vertices[i][j];
    }
  }

  return data;
}

// ITK image types
typedef itk::VectorImage< float, 3 >  ODFImageType; // ODF is in float in DSI studio

ODFImageType::Pointer loadITK(std::string filename) // returns the sph. harm coeffs of the ODF
{
  typedef itk::ImageFileReader< ODFImageType >  ODFReaderType;
  ODFReaderType::Pointer ODFReader       = ODFReaderType::New();
  ODFImageType::Pointer  ODFCoeffsImage  = ODFImageType::New();

  std::cout<<"Status : Loading ODF ITK image: "<<filename<<" ... ";
  ODFReader->SetFileName ( filename ) ;
  try
  {
    ODFReader->Update() ; 
  }
  catch( itk::ExceptionObject & excp )
  {
    std::cout << "FAIL" << std::endl << "Error  : Problem reading the input ODF file: " << filename <<  std::endl;
    std::cout << excp << std::endl;
    return NULL;
  }
  ODFCoeffsImage = ODFReader->GetOutput();
  std::cout<<"DONE"<<std::endl;

  // TODO: Check number of components in ODFCoeffsImage: it must be 15

  return ODFCoeffsImage;
} // loadITK()

template< class T > typename itk::Image< T, 3 >::Pointer loadScalarITKImage( std::string ScalarImageFilename )
{
  typedef itk::Image < T, 3 > ImageType ;
  typedef itk::ImageFileReader< ImageType >  ReaderType;
  typename ReaderType::Pointer Reader = ReaderType::New();
  typename ImageType::Pointer  Image  = ImageType::New();

  std::cout<<"Status : Loading scalar ITK image: "<<ScalarImageFilename<<" ... ";

  Reader->SetFileName ( ScalarImageFilename ) ;
  try
  {
    Reader->Update() ; 
  }
  catch( itk::ExceptionObject & excp )
  {
    std::cerr << "Error  : Problem reading the input scalar image: " << ScalarImageFilename <<  std::endl;
    std::cerr << excp << std::endl;
    return NULL;
  }
  Image = Reader->GetOutput();

  std::cout<<"DONE"<<std::endl;

  return Image;
}

void MaskFAImage ( double* FAArray, short* MaskArray, unsigned long ArraySize )
{
  for( unsigned long index = 0 ; index < ArraySize ; index++ )
  {
    if( MaskArray[index] == 0 ) // if outside of mask
    {
      FAArray[index] = 0;
    }
  }
  return;
}

// Master function
bool writeFib(ODFImageType::Pointer ODFCoeffsImage, std::string outputODFfib, std::string maskImageFilename, std::string FAImageFilename)
{
  MatFile mat_writer(outputODFfib.c_str());

// add_matrix creates the matrix and write it to file
// template<typename Type>    void add_matrix(const char* name,const Type* data_ptr,unsigned int rows,unsigned int cols)

  // Reconstruct ODF: convert sph. harm. coeffs to ODF value by vertex by sampling coeffs on vertices
  std::cout<<"Status : Reconstructing ODF (can take some time) ... ";
  ODFReconstructor ODFreconstructor ( ODFCoeffsImage, NbDirs/2, 15, datFile ); // ODFReconstructor(ODFImageType::Pointer Input_image, unsigned long numberOfSamplesOnSphere, unsigned long numberOfSpharm, std::string filename )
  ODFImageType::Pointer ODFSampledImage = ODFreconstructor.ReconstructODFImage(); // ODFSampledImage is a vector image that contains sampled ODF for each vertex on the sphere // m_ODFImage->SetVectorLength ( numberOfSamplesOnSphere * 2) ;
  std::cout<<"DONE"<<std::endl;

  //Size
  ODFImageType::SizeType size  = ODFSampledImage->GetLargestPossibleRegion().GetSize();
  short sizeArray[3] = {size[0], size[1], size[2]}; // SizeValueType = unsigned long  -> short
  mat_writer.add_matrix("dimension", sizeArray, 1, 3);

  // Spacing
  ODFImageType::SpacingType spacing = ODFSampledImage->GetSpacing();
  float spacingArray[3] = {spacing[0], spacing[1], spacing[2]}; // SpacingValueType = double  -> float
  mat_writer.add_matrix("voxel_size", spacingArray, 1, 3);

//  ODFImageType::PointType     origin    = ODFSampledImage->GetOrigin();
//  ODFImageType::DirectionType direction = ODFSampledImage->GetDirection();

  // odf_vertices
  double* VerticesArray = GetArrayFromFile< double >(datFile, true);
  mat_writer.add_matrix("odf_vertices", VerticesArray, 3, NbDirs);
  delete []VerticesArray;

  // odf_faces
  short* FacesArray = GetArrayFromFile< short >(FacesFile, false);
  mat_writer.add_matrix("odf_faces", FacesArray, 3, NbFaces);
  delete []FacesArray;

// TODO: Check size of images (ODF, mask and fa) to check they are the same

  // FA
  // !! declaration of itk::Image< T, 3 >::Pointer needed otherwise empty arrays
  itk::Image< short, 3 >::Pointer  MaskImage = loadScalarITKImage< short >( maskImageFilename );
  short* MaskArray = MaskImage->GetPixelContainer()->GetBufferPointer();
  itk::Image< double, 3 >::Pointer FAImage   = loadScalarITKImage< double >( FAImageFilename );
  double* FAArray  = FAImage->GetPixelContainer()->GetBufferPointer();
  MaskFAImage( FAArray, MaskArray, size[0]*size[1]*size[2] ); // will modify FAArray
  mat_writer.add_matrix("gfa", FAArray, 1, size[0]*size[1]*size[2]);

  // Read ODF array and fill vector with matrices to be written out
  std::cout<<"Status : Converting ODF data ... ";
  float* ODFArray = ODFSampledImage->GetPixelContainer()->GetBufferPointer();
  std::vector< float > ODFFibVector;
  int ODFBlockIndex = 0;
  int ODFCurrentBlockSize = 0;
  unsigned long Voxelindex = 0 ;
  unsigned long BlockStartVoxelIndex = 0 ;
  while( Voxelindex < size[0]*size[1]*size[2] ) // while there are voxels to convert
  {
    if( size[0]*size[1]*size[2] - Voxelindex >= ODFBlockSize) // if there is more than 'ODFBlockSize' remaining voxels => block of 'ODFBlockSize' voxels
    {
      ODFCurrentBlockSize = ODFBlockSize;
    }
    else // last block: size = nb of remaining voxels
    {
      ODFCurrentBlockSize = size[0]*size[1]*size[2] - Voxelindex;
    }
    ODFFibVector.resize( ODFCurrentBlockSize * NbDirs/2 );
    BlockStartVoxelIndex = Voxelindex;

    // for all directions
    for ( unsigned int dir=0; dir < NbDirs/2 ; ++dir )
    {
      Voxelindex = BlockStartVoxelIndex;

      // for all voxels supposed to be in the block
      for ( unsigned int ODFBlockVoxelIndex=0; ODFBlockVoxelIndex < ODFCurrentBlockSize ; ++ODFBlockVoxelIndex, ++Voxelindex )
      {
        ODFFibVector[ dir*ODFCurrentBlockSize + ODFBlockVoxelIndex ] = ODFArray[ Voxelindex*NbDirs + dir ] ;
      }
    } // for all directions  =>  end of the current block

    std::ostringstream ODFBlockIndexout;
    ODFBlockIndexout << ODFBlockIndex;
    ODFBlockIndex++;
    std::string ODFMatrixName = "odf" + ODFBlockIndexout.str();

    mat_writer.add_matrix(ODFMatrixName.c_str(), &*ODFFibVector.begin(), NbDirs/2, ODFCurrentBlockSize);

  } // while there are voxels to convert

/*
ODFArray (ITK image):
 642   642   642   642
-----|-----|-----|-----|...    x 1000000 voxels

ODFFibArray (Fib image):
   20000       20000       20000
-----------|-----------|-----------|...    x 321 dirs

dir        E [0 ; 320]    -> dir
BlockVoxel E [0 ; 19999]  -> ODFBlockVoxelIndex
voxel      E [0 ; 999999] -> Voxelindex

==> ODFFibArray[ dir*20000 + BlockVoxel ] = ODFArray[ voxel*642 + dir ] ;
*/

  std::cout<<"DONE"<<std::endl;
  std::cout<<"Status : ODF converted in "<< ODFBlockIndex <<" blocks"<<std::endl;

  return true;
}

  /////////////////////////////////////////
 //            FIB -> ITK               //
/////////////////////////////////////////

template<class T > void WriteITKScalarImage( T* data_ptr, std::string filename, typename itk::ImageBase< 3 >::SizeType size, typename itk::ImageBase< 3 >::SpacingType spacing )
{
  std::cout<<"Status : Writing out ITK scalar image: " << filename << " ... ";

  // ITK types and definitions
  typedef itk::Image <T, 3>  ImageType ;
  typename ImageType::Pointer NewImage = ImageType::New() ;
  NewImage->SetSpacing ( spacing ) ;

  //// Set Image properties

  // origin
  typename ImageType::PointType origin ;
  origin[0] = 0;
  origin[1] = 0;
  origin[2] = 0;
  NewImage->SetOrigin ( origin ) ;

  // direction
//  ImageType::DirectionType direction;
//  NewImage->SetDirection ( direction ) ;

  // region (size)
  typename ImageType::IndexType start;
  start[0] = 0;
  start[1] = 0;
  start[2] = 0;
  typename ImageType::RegionType region;
  region.SetSize ( size ) ;
  region.SetIndex ( start ) ;
  NewImage->SetRegions ( region ) ;

  // Allocate image
  NewImage->Allocate () ;
  NewImage->FillBuffer ( 0 ) ;

  // Buffer Array
  T *NewImageArray;
  NewImageArray = NewImage->GetPixelContainer()->GetBufferPointer() ;

  // Fill buffer
  for( int i = 0 ; i < size[0]*size[1]*size[2] ; i++ )
  {
    NewImageArray[ i ] = data_ptr[ i ];
  }

  // Write out image
  typedef itk::ImageFileWriter < ImageType > WriterType ;
  typename WriterType::Pointer Writer = WriterType::New() ;
  Writer->SetFileName ( filename ); 
  Writer->SetInput( NewImage );
  Writer->SetUseCompression(true);

  try
  {
    Writer->Update() ;
  }
  catch ( itk::ExceptionObject & excp )
  {
    std::cerr << "Problem writing the image: " << filename << std::endl ;
    std::cerr << excp << std::endl ;
  }

  std::cout<<"DONE"<<std::endl;

  return;
} // void WriteITKScalarImage()

template<class T > void GetVertices( T* data_ptr, int nbVertices, std::string filename ) // matrix dim = (3, nbVertices)
{
  std::cout<<"Status : Writing file: " << filename <<std::endl;

  std::ofstream VerticesFileStream (filename.c_str() , std::ios::out | std::ios::trunc); // opening in writing with erasing the open file
  if(! VerticesFileStream)
  {
    std::cout<<"Error : Creating file: "<< filename <<std::endl;
    return;
  }

  for( int j = 0 ; j < nbVertices ; j++ ) // 1 vertex by line
  {
    VerticesFileStream << data_ptr[ j ] << " " << data_ptr[ nbVertices + j ] << " " << data_ptr[ 2*nbVertices + j ] << std::endl;
  }

  VerticesFileStream.close();

  return;
}

// Master Function
bool writeITK( std::string filename, std::string outputODFITK)
{
  std::cout<<"Status : Reading fib file"<<std::endl;

  std::string outputFolder = itksys::SystemTools::GetRealPath( itksys::SystemTools::GetFilenamePath(outputODFITK).c_str() );

  MatFile mat_reader;
  mat_reader.load_from_file( filename.c_str() );
  if( mat_reader.get_matrix_count() == 0)
  {
    return false;
  }

  // Display content of file
  std::cout<< "==========================" <<std::endl;
  for (unsigned int index = 0; index < mat_reader.get_matrix_count() ; ++index)
  {
    std::cout<< mat_reader.get_matrix_name(index) <<std::endl;
  }
  std::cout<< "==========================" <<std::endl;

  // Get Data

  unsigned int row,col;

  // dim & spacing
  short* dim = 0;
  mat_reader.get_matrix("dimension",row,col,dim);
  std::cout<< row << " " << col << " | " << dim[0] <<" " <<  dim[1] << " " << dim[2] << " dimension"  <<std::endl;
  itk::ImageBase< 3 >::SizeType size;
  size[0] = dim[0];
  size[1] = dim[1];
  size[2] = dim[2];

  double* vs = 0;
  mat_reader.get_matrix("voxel_size",row,col,vs);
  std::cout<< row << " " << col << " | " << vs[0] <<" " <<  vs[1] << " " << vs[2] << " voxel_size" <<std::endl;
  itk::ImageBase< 3 >::SpacingType spacing;
  spacing[0] = vs[0];
  spacing[1] = vs[1];
  spacing[2] = vs[2];

  // odf vertices
  float* odfVertices = 0;
  mat_reader.get_matrix("odf_vertices",row,col,odfVertices);
  std::cout<< row << " " << col << " odf_vertices" <<std::endl;
  GetVertices< float >(odfVertices, col, (outputFolder + "/odf_vertices.txt").c_str());

  // odf faces
  short* odfFaces = 0;
  mat_reader.get_matrix("odf_faces",row,col,odfFaces);
  std::cout<< row << " " << col << " odf_faces" <<std::endl;
  GetVertices< short >(odfFaces, col, (outputFolder + "/odf_faces.txt").c_str());

  // fa
  double* fa;
  mat_reader.get_matrix("gfa",row,col,fa);
  std::cout<< row << " " << col << " gfa" <<std::endl;
  WriteITKScalarImage< double >( fa, outputFolder + "/gfa.nrrd", size, spacing );

  return true;

} // bool writeITK()

  /////////////////////////////////////////
 //                MAIN                 //
/////////////////////////////////////////

int main (int argc, char* argv[])
{
  PARSE_ARGS;

/* Check input args */
  if( ODFfib == "" &&  ODFitk == "" )
  {
    std::cout<<"Error  : Please give an input ODF image."<<std::endl;
    return 1;
  }

  if( ODFfib != "" &&  ODFitk != "" )
  {
    std::cout<<"Warning: As both ITK and fib files have been given, the ITK image will be used."<<std::endl;
    ODFfib = ""; // so the ITK image is used
  }

  if( ODFitk != "" &&  fa == "" ) // TODO: FA can be any scalar image to display with the ODF in DSI studio
  {
    std::cout<<"Error  : A FA image is required to convert ITK image to fib file."<<std::endl;
    return 1;
  }

  if( ODFitk != "" &&  mask == "" ) // TODO: If no mask given, create a mask image of the size of the ODF filled with all ones
  {
    std::cout<<"Error  : A mask is required to convert ITK image to fib file."<<std::endl;
    return 1;
  }

  if( outputODF == "" )
  {
    if( ODFfib != "" )
    {
      outputODF = "./ODF.nrrd";
    }
    else
    {
      outputODF = "./ODF.fib.gz";
    }
    std::cout<<"Warning: No output image given, the output image will be: "<< outputODF <<std::endl;
  }

/* Convert image */
  if( ODFfib != "" ) // fib -> ITK
  {
    if( !writeITK( ODFfib, outputODF ) )
    {
      return 1;
    }
  }
  else // ITK -> fib
  {
   if( ! writeFib( loadITK(ODFitk), outputODF, mask, fa ) )
    {
      return 1;
    }
  }

  return 0;

} // int main

/*

// WRITE .fib file

src/libs/dsi/odf_process.hpp
    -> 120: virtual void end(Voxel& voxel,MatFile& mat_writer) ->  mat_writer.add_matrix()
    -> 60: const unsigned int odf_block_size = 20000;
    -> struct OutputODF
    -> 75: OutputODF::init() -> ODF contain only voxels in mask
    -> std::vector<std::vector<float> > odf_data;  => ODF data stored in float

// .fib file

src/mainwindow.cpp: void MainWindow::loadFib(QString filename)
    -> std::auto_ptr<ODFModel> new_handle(new ODFModel);  -> new_handle = ptr on ODFModel
    -> new_handle->load_from_file( filename )

src/libs/tracking/tracking_model.hpp: class ODFModel
     -> ODFModel::load_from_file() -> fib_data.load_from_file()
     -> public:  FibData fib_data;

src/libs/tracking/fib_data.hpp: class FibData
     -> FibData::load_from_file() -> mat_reader.load_from_file() -> fib.add_data(mat_reader)
     -> public:  MatFile mat_reader;

src/libs/mat_file.hpp: class MatFile
     ===> MatFile::load_from_file()
     ===> MatFile::write_to_file()

src/libs/tracking/fib_data.hpp: class FiberDirection
     ===> FiberDirection::add_data()
     ===> FiberDirection contains ODFData

src/libs/tracking/fib_data.hpp: struct ODFData
     ===> ODFData contains odfs


// ODF vertices

src/libs/dsi/tessellated_icosahedron.hpp: class tessellated_icosahedron


// Name of .fib file

src/reconstruction/reconstruction_window.cpp: void reconstruction_window::doReconstruction()
    -> const char* msg = (const char*)reconstruction();

src/libs/dsi/dsi_interface_imp.cpp: const char* reconstruction()


// .src file

src/mainwindow.cpp: void MainWindow::loadSrc(QStringList filenames)
    ->  reconstruction_window* new_mdi = new reconstruction_window(filenames,this);

src/reconstruction/reconstruction_window.cpp: reconstruction_window::reconstruction_window()
    -> load_src(0);
    -> bool reconstruction_window::load_src(int index)
    -> handle->load_from_file(filenames[index].toLocal8Bit().begin())

src/reconstruction/reconstruction_window.h: class reconstruction_window:
    -> private:  std::auto_ptr<ImageModel> handle;

src/libs/dsi/image_model.hpp: struct ImageModel
    -> ImageModel.load_from_file() -> mat_reader->load_from_file()
    -> public:   std::auto_ptr<MatFile> mat_reader;

src/libs/mat_file.hpp: class MatFile
     ===> MatFile::load_from_file()
     ===> MatFile::write_to_file()

*/
