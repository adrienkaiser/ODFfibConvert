/*
./ODFfibConvert --ODFfib /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/dwi-00.src.gz.odf8.f5rec.qbi.sh8.0.006.fib.gz
./ODFfibConvert --ODFitk /home/akaiser/Networking/NFG/nfg_1.1.1/generated_collections/130325112527/DWI/odf.nrrd
*/

/* std classes */
#include <vector>
#include <fstream>
#include <iostream>

#include "zlib.h"

/* ITK classes */
#include <itkImage.h>
#include <itkImageBase.h> // for SizeType and SpacingType without having to declare an ImageType
#include <itkImageFileReader.h>
#include <itkImageFileWriter.h>
#include <itkVectorImage.h>
#include <itksys/SystemTools.hxx>

/* Homemade classes */
#include "ODFfibConvertCLP.h" //generated when ccmake
#include "ODFReconstructor.h" // Comes from COST, modified to have ODFType = float instead of double and comment all std::cout

/* types */
#define DOUBLE  0
#define FLOAT   10
#define UINT    20
#define SHORT   30
#define USHORT  40
#define UCHAR   50

const unsigned int element_size_array[10] = {8,4,4,2,2,1,0,0,0,0};
/*
char              1byte
short int (short) 2bytes
int               4bytes
long int (long)   4bytes
bool              1byte
float             4bytes
double            8bytes
long double       8bytes
*/

unsigned int NbDirs = 642; // Icosahedron tesselation (subdivision of the whole sphere) in DSI studio
unsigned int NbFaces = 1280;
const unsigned int ODFBlockSize = 20000; // DSIstudio/libs/dsi/odf_process.hpp:60
std::string datFile = "${CMAKE_CURRENT_SOURCE_DIR}/ODFVertices.dat";
std::string FacesFile = "${CMAKE_CURRENT_SOURCE_DIR}/ODFFaces.dat";

  /////////////////////////////////////////
 //           MAT MATRIX CLASS          //
/////////////////////////////////////////

// dsistudio/libs/mat_file.hpp:62:  class MatMatrix
// dsistudio/libs/mat_file.hpp:306: class MatFile
class MatMatrix
{
public:
  // Data
  std::string name;
  unsigned int type;
  unsigned int rows;
  unsigned int cols;
  unsigned int count;
  unsigned int namelen;
  std::vector<char> data_buf;
  char* data_ptr;

  MatMatrix(void):type(0),rows(0),cols(0),data_ptr(0) {}
  MatMatrix(const std::string& name_):namelen(name_.size()+1),name(name_),data_ptr(0) {}

  template<class T> void assign(const T* data_ptr_,unsigned int rows_,unsigned int cols_,unsigned int type_)
  {
    data_ptr = (char*)data_ptr_;
    rows = rows_;
    cols = cols_;
    type = type_;
    count = rows * cols ;
  }

  // FIB -> ITK
  bool readMat(void* in)
  { 
    unsigned int imagf = 0; // content useless but variable necessary

    if (gzread(in,(char*)&type,4) == -1 || type > 100 || type % 10 > 1) return false;
    if (type % 10) type = 0; // text
    if (gzread(in,(char*)&rows,4) == -1) return false;
    if (gzread(in,(char*)&cols,4) == -1) return false;
    if (gzread(in,(char*)&imagf,4) == -1) return false;
    if (gzread(in,(char*)&namelen,4) == -1) return false;
    std::vector<char> buffer(namelen+1);
    if (gzread(in,(char*)&*buffer.begin(),namelen) == -1) return false;

    count = rows*cols;
    name = &*buffer.begin();

    unsigned int total_size = count*element_size_array[(type%100)/10];
    try
    {
      std::vector<char> allocator(total_size);
      allocator.swap(data_buf); // swap ?? => allocate memory ??
    }
    catch (...)
    {
      return false;
    }
    data_ptr = &*data_buf.begin(); // data_buf only used to allocate memory

    return gzread(in,(char*)data_ptr,total_size) != -1;
  }

  // ITK -> FIB
  bool writeMat(void* out)
  {
    unsigned int imagf = 0;
    gzwrite( out, (const char*)&type, 4 );
    gzwrite( out, (const char*)&rows, 4 );
    gzwrite( out, (const char*)&cols, 4 );
    gzwrite( out, (const char*)&imagf, 4 );
    gzwrite( out, (const char*)&namelen, 4 );
    gzwrite( out, (const char*)&*name.begin(), namelen );
    gzwrite( out, (const char*)data_ptr, rows*cols*element_size_array[(type%100)/10] );

    return true;
  }

}; // class MatMatrix

  /////////////////////////////////////////
 //            ITK -> FIB               //
/////////////////////////////////////////

bool writeOutFibFile(std::vector<MatMatrix*> ImageMatrices, std::string filename)
{
  std::cout<<"Status : Writing out fib ODF image: " << filename << " ... ";

  // Open gz file for writing
  void* out = gzopen(filename.c_str(), "wb");

  for(unsigned int i=0; i<ImageMatrices.size(); ++i)
  {
/*    std::cout<<"======== MAT ================================="<<std::endl;
    std::cout<<"type\trows\tcols\tnamelen\tcount\tname"<<std::endl;
    std::cout<<ImageMatrices[i]->type<<"\t";
    std::cout<<ImageMatrices[i]->rows<<"\t";
    std::cout<<ImageMatrices[i]->cols<<"\t";
    std::cout<<ImageMatrices[i]->namelen<<"\t";
    std::cout<<ImageMatrices[i]->count<<"\t";
    std::cout<<ImageMatrices[i]->name<<"\t"<<std::endl;
*/

    if( !ImageMatrices[i]->writeMat(out) )
    {
      std::cout<<"FAIL"<<std::endl;
      return false;
    }
  }

  std::cout<<"DONE"<<std::endl;

  gzclose(out);

  return true;
}

// Create a MatMatrix with all infos from data array
// Function = equivalent of void MatFile::add_matrix() called by void OutputODF::end() with &*data to be const ??
template< class T > MatMatrix* GetMatMatrixFromData (const T* data, unsigned int Mrows, unsigned int Mcols, unsigned int Mtype, const char* MName )
{
  MatMatrix* matrix(new MatMatrix(MName));

  matrix -> assign< T >(data, Mrows, Mcols, Mtype);

  return matrix;
}

template< class T > T* GetArrayFromFile( std::string filename, bool SkipFirstLine ) // SkipFirstLine needed for vertices file (datFile: first line = nb of vertices)
{
  std::ifstream InfileStream (filename.c_str() , std::ios::in); // open in reading
  if(! InfileStream) // error while opening
  {
    return NULL;
  }

  // Get data in a 2 dim vector
  std::vector< std::vector< T > > Vertices;
  Vertices.resize(3);

  std::string line;
  T x, y, z;

  if( SkipFirstLine ) // void read to avoid reading the first line as triple
  {
    std::getline( InfileStream, line );
  }

  while( std::getline( InfileStream, line ) ) 
  {
    std::stringstream linestr(line);
    linestr >> x >> y >> z;

    Vertices[0].push_back(x);
    Vertices[1].push_back(y);
    Vertices[2].push_back(z);
  }

  InfileStream.close();

  // Write data in a 1 dim array
  T* data = new T [ 3 * Vertices[0].size() ] ; // delete after function call in writeFib()

  for( int i = 0 ; i < 3 ; i++ )
  {
    for( int j = 0 ; j < Vertices[0].size() ; j++ )
    {
      data[i*j] = Vertices[i][j];
    }
  }

  return data;
}

// ODF type
typedef itk::VectorImage< float, 3 > ODFImageType; // ODF is in float in DSI studio

bool writeFib(ODFImageType::Pointer ODFCoeffsImage, std::string outputODFfib)
{
  std::vector<MatMatrix*> ImageMatrices;

  // Reconstruct ODF: convert sph. harm. coeffs to ODF value by vertex by sampling coeffs on vertices
  std::cout<<"Status : Reconstructing ODF (can take some time) ... ";

  typedef itk::Image < double, 3 > FAImageType ;
  ODFImageType::Pointer ODFSampledImage = ODFImageType::New();
  FAImageType::Pointer  FAImage         = FAImageType::New();

  ODFReconstructor ODFreconstructor ( ODFCoeffsImage, NbDirs/2, 15, datFile ); // ODFReconstructor(ODFImageType::Pointer Input_image, unsigned long numberOfSamplesOnSphere, unsigned long numberOfSpharm, std::string filename )
  ODFSampledImage = ODFreconstructor.ReconstructODFImage(); // ODFSampledImage is a vector image that contains sampled ODF for each vertex on the sphere // m_ODFImage->SetVectorLength ( numberOfSamplesOnSphere * 2) ;
  FAImage = ODFreconstructor.GetFAImage();

  std::cout<<"DONE"<<std::endl;

  //Size
  ODFImageType::SizeType size  = ODFSampledImage->GetLargestPossibleRegion().GetSize();
  short sizeArray[3] = {size[0], size[1], size[2]}; // SizeValueType = unsigned long  -> short
  ImageMatrices.push_back( GetMatMatrixFromData< short >(sizeArray, 1, 3, SHORT, "dimension") );

  // Spacing
  ODFImageType::SpacingType spacing = ODFSampledImage->GetSpacing();
  float spacingArray[3] = {spacing[0], spacing[1], spacing[2]}; // SpacingValueType = double  -> float
  ImageMatrices.push_back( GetMatMatrixFromData< float >( spacingArray, 1, 3, FLOAT, "voxel_size") );

//  ODFImageType::PointType     origin    = ODFSampledImage->GetOrigin();
//  ODFImageType::DirectionType direction = ODFSampledImage->GetDirection();

  // odf_vertices
  double* VerticesArray = GetArrayFromFile< double >(datFile, true);
  ImageMatrices.push_back( GetMatMatrixFromData< double >( VerticesArray, 3, NbDirs, DOUBLE, "odf_vertices") );
  delete []VerticesArray;

  // odf_faces
  short* FacesArray = GetArrayFromFile< short >(FacesFile, false);
  ImageMatrices.push_back( GetMatMatrixFromData< short >( FacesArray, 3, NbFaces, SHORT, "odf_faces") );
  delete []FacesArray;

  // FA
  double *FAArray = FAImage->GetPixelContainer()->GetBufferPointer();
  ImageMatrices.push_back( GetMatMatrixFromData< double >( FAArray, 1, size[0]*size[1]*size[2], DOUBLE, "gfa") );

  // Read ODF array and fill vector with matrices to be written out
  std::cout<<"Status : Converting ODF data ... ";
  float* ODFArray = ODFSampledImage->GetPixelContainer()->GetBufferPointer();
  std::vector< float > ODFFibVector;
  int ODFBlockIndex = 0;
  int ODFCurrentBlockSize = 0;
  unsigned long Voxelindex = 0 ;
  unsigned long BlockStartVoxelIndex = 0 ;
  while( Voxelindex < size[0]*size[1]*size[2] ) // while there are voxels to convert
  {
    if( size[0]*size[1]*size[2] - Voxelindex >= ODFBlockSize) // if there is more than 'ODFBlockSize' remaining voxels => block of 'ODFBlockSize' voxels
    {
      ODFCurrentBlockSize = ODFBlockSize;
    }
    else // last block: size = nb of remaining voxels
    {
      ODFCurrentBlockSize = size[0]*size[1]*size[2] - Voxelindex;
    }
    ODFFibVector.resize( ODFCurrentBlockSize * NbDirs/2 );
    BlockStartVoxelIndex = Voxelindex;

    // for all directions
    for ( unsigned int dir=0; dir < NbDirs/2 ; ++dir )
    {
      Voxelindex = BlockStartVoxelIndex;

      // for all voxels supposed to be in the block
      for ( unsigned int ODFBlockVoxelIndex=0; ODFBlockVoxelIndex < ODFCurrentBlockSize ; ++ODFBlockVoxelIndex, ++Voxelindex )
      {
        ODFFibVector[ dir*ODFCurrentBlockSize + ODFBlockVoxelIndex ] = ODFArray[ Voxelindex*NbDirs + dir ] ;
      }
    } // for all directions  =>  end of the current block

    std::ostringstream ODFBlockIndexout;
    ODFBlockIndexout << ODFBlockIndex;
    ODFBlockIndex++;
    std::string ODFMatrixName = "odf" + ODFBlockIndexout.str();

    ImageMatrices.push_back( GetMatMatrixFromData< float >( &*ODFFibVector.begin(), NbDirs/2, ODFCurrentBlockSize, FLOAT, ODFMatrixName.c_str() ) );

  } // while there are voxels to convert

/*
ODFArray (ITK image):
 642   642   642   642
-----|-----|-----|-----|...    x 1000000 voxels

ODFFibArray (Fib image):
   20000       20000       20000
-----------|-----------|-----------|...    x 321 dirs

dir        E [0 ; 320]    -> dir
BlockVoxel E [0 ; 19999]  -> ODFBlockVoxelIndex
voxel      E [0 ; 999999] -> Voxelindex

==> ODFFibArray[ dir*20000 + BlockVoxel ] = ODFArray[ voxel*642 + dir ] ;
*/

  std::cout<<"DONE"<<std::endl;
  std::cout<<"Status : ODF converted in "<< ODFBlockIndex <<" blocks"<<std::endl;

  // Write out fib file
  if( !writeOutFibFile(ImageMatrices,outputODFfib) )
  {
    return false;
  }

  return true;
}

ODFImageType::Pointer loadITK(std::string filename) // returns the coeffs of the sph. harm of the ODF
{
  typedef itk::ImageFileReader< ODFImageType >  ODFReaderType;
  ODFReaderType::Pointer ODFReader       = ODFReaderType::New();
  ODFImageType::Pointer  ODFCoeffsImage  = ODFImageType::New();

  std::cout<<"Status : Loading ODF ITK image: "<<filename<<" ... ";
  ODFReader->SetFileName ( filename ) ;
  try
  {
    ODFReader->Update() ; 
  }
  catch( itk::ExceptionObject & excp )
  {
    std::cerr << "Error  : Problem reading the input ODF file: " << filename <<  std::endl;
    std::cerr << excp << std::endl;
    return NULL;
  }
  ODFCoeffsImage = ODFReader->GetOutput();
  std::cout<<"DONE"<<std::endl;

  return ODFCoeffsImage;
} // loadITK()

  /////////////////////////////////////////
 //            FIB -> ITK               //
/////////////////////////////////////////

std::vector<MatMatrix*> loadFib(std::string filename)
{
  std::vector<MatMatrix*> ImageMatrices;
  std::vector<MatMatrix*> EmptyVector; // EXIT_FAILURE

  std::cout<<"Status : Loading fib file: "<<filename<<" ... ";

  void* in = gzopen(filename.c_str(), "rb");
  if (!in)
  {
     std::cout<<"Error  : gzopen failed"<<std::endl;
     return EmptyVector;
  }

  for(unsigned int index = 0 ; !gzeof(in) ; ++index)
  {
    MatMatrix * matrix= new MatMatrix;

    if(!matrix->readMat(in))
    {
      std::cout<<"Error  : read matrix failed"<<std::endl;
      return EmptyVector;
    }

    ImageMatrices.push_back(matrix);

  } // for()

  gzclose(in);

  std::cout<<"DONE"<<std::endl;

  return ImageMatrices;

} // std::vector<MatMatrix*> loadFib()

template<class T > void GetSize( char* data_ptr , itk::ImageBase< 3 >::SizeType &size )
{
  for( int i = 0 ; i < 3 ; i++ )
  {
    size[ i ] = static_cast< itk::ImageBase< 3 >::SizeValueType > ( *(T *)( data_ptr + sizeof(T) * i ) );  // char= 1 byte => get N bytes of the char array for each T
    //                                            SizeValueType = unsigned long
  }
}

template<class T > void GetSpacing( char* data_ptr , itk::ImageBase< 3 >::SpacingType &spacing )
{
  for( int i = 0 ; i < 3 ; i++ )
  {
    spacing[ i ] = static_cast< itk::ImageBase< 3 >::SpacingValueType > ( *(T *)( data_ptr + sizeof(T) * i ) );  // char= 1 byte => get N bytes of the char array for each T
    //                                               SpacingValueType = double
  }
}

template<class T > void WriteITKScalarImage( char* data_ptr, std::string filename, typename itk::Image <T, 3>::SizeType size, typename itk::Image <T, 3>::SpacingType spacing )
{
  std::cout<<"Status : Writing out ITK scalar image: " << filename << " ... ";

  // ITK types and definitions
  typedef itk::Image <T, 3>  ImageType ;
  typename ImageType::Pointer NewImage = ImageType::New() ;
  NewImage->SetSpacing ( spacing ) ;

  //// Set Image properties

  // origin
  typename ImageType::PointType origin ;
  origin[0] = 0;
  origin[1] = 0;
  origin[2] = 0;
  NewImage->SetOrigin ( origin ) ;

  // direction
//  ImageType::DirectionType direction;
//  NewImage->SetDirection ( direction ) ;

  // region (size)
  typename ImageType::IndexType start;
  start[0] = 0;
  start[1] = 0;
  start[2] = 0;
  typename ImageType::RegionType region;
  region.SetSize ( size ) ;
  region.SetIndex ( start ) ;
  NewImage->SetRegions ( region ) ;

  // Allocate image
  NewImage->Allocate () ;
  NewImage->FillBuffer ( 0 ) ;

  // Buffer Array
  T *NewImageArray;
  NewImageArray = NewImage->GetPixelContainer()->GetBufferPointer() ;

  // Cast data and fill buffer
  for( int i = 0 ; i < size[0]*size[1]*size[2] ; i++ )
  {
    NewImageArray[ i ] = *(T *)( data_ptr + sizeof(T) * i ) ;  // char= 1 byte => get N bytes of the char array for each T
  }

  // Write out image
  typedef itk::ImageFileWriter < ImageType > WriterType ;
  typename WriterType::Pointer Writer = WriterType::New() ;
  Writer->SetFileName ( filename ); 
  Writer->SetInput( NewImage );
  Writer->SetUseCompression(true);

  try
  {
    Writer->Update() ;
  }
  catch ( itk::ExceptionObject & excp )
  {
    std::cerr << "Problem writing the image: " << filename << std::endl ;
    std::cerr << excp << std::endl ;
  }

  std::cout<<"DONE"<<std::endl;

  return;
} // void WriteITKScalarImage()


template<class T > void GetVertices( char* data_ptr, int nbVertices, std::string filename ) // matrix dim = (3, nbVertices)
{
  std::cout<<"Status : Writing file: " << filename <<std::endl;

  std::vector< std::vector< T > > Vertices;
  Vertices.resize(3);

  // Get vertices
  for( int i = 0 ; i < 3 ; i++ )
  {
    Vertices[i].resize(nbVertices);
    for( int j = 0 ; j < nbVertices ; j++ )
    {
      Vertices[i][j] = *(T *)( data_ptr + sizeof(T) * i*j ) ;  // char= 1 byte => get N bytes of the char array for each T
//std::cout << Vertices[i][j]  << std::endl;
    }
  }

  // Write out in a file
  std::ofstream VerticesFileStream (filename.c_str() , std::ios::out | std::ios::trunc);  // opening in writing with erasing the open file
  if(! VerticesFileStream)
  {
    std::cout<<"Error  : Creating file: "<< filename <<std::endl;
    return;
  }

  for( int j = 0 ; j < nbVertices ; j++ ) // 1 vertex by line
  {
    VerticesFileStream << Vertices[0][j] << " " << Vertices[1][j] << " " << Vertices[2][j] << std::endl;
  }

  VerticesFileStream.close();

  return;
}

// Master Function

bool writeITK( std::vector<MatMatrix*> ImageMatrices, std::string outputODFITK)
{
  std::cout<<"Status : Writing ITK image: "<<outputODFITK<<std::endl;

  std::string outputFolder = itksys::SystemTools::GetRealPath( itksys::SystemTools::GetFilenamePath(outputODFITK).c_str() );

  itk::ImageBase< 3 >::SizeType    size;
  itk::ImageBase< 3 >::SpacingType spacing;
  float z0;

  std::vector< std::string > ImagesToWriteOut; // = {"gfa", "iso", "fa0", "fa1", "fa2", "fa3", "fa4", "nqa0", "nqa1", "nqa2", "nqa3", "nqa4", "index0", "index1", "index2", "index3", "index4"};
  ImagesToWriteOut.push_back("gfa");
  ImagesToWriteOut.push_back("iso");
  ImagesToWriteOut.push_back("fa0");
  ImagesToWriteOut.push_back("fa1");
  ImagesToWriteOut.push_back("fa2");
  ImagesToWriteOut.push_back("fa3");
  ImagesToWriteOut.push_back("fa4");
  ImagesToWriteOut.push_back("nqa0");
  ImagesToWriteOut.push_back("nqa1");
  ImagesToWriteOut.push_back("nqa2");
  ImagesToWriteOut.push_back("nqa3");
  ImagesToWriteOut.push_back("nqa4");
  ImagesToWriteOut.push_back("index0");
  ImagesToWriteOut.push_back("index1");
  ImagesToWriteOut.push_back("index2");
  ImagesToWriteOut.push_back("index3");
  ImagesToWriteOut.push_back("index4");

  // for all matrices
  for (unsigned int index = 0; index < ImageMatrices.size() ;++index)
  {
    // Display matrix content
    std::cout<<"======== MAT ================================="<<std::endl;
    std::cout<<"type\trows\tcols\tnamelen\tcount\tname"<<std::endl;
    std::cout<<ImageMatrices[index]->type<<"\t";
    std::cout<<ImageMatrices[index]->rows<<"\t";
    std::cout<<ImageMatrices[index]->cols<<"\t";
    std::cout<<ImageMatrices[index]->namelen<<"\t";
    std::cout<<ImageMatrices[index]->count<<"\t";
    std::cout<<ImageMatrices[index]->name<<"\t"<<std::endl;

    // Dimension
    if( ImageMatrices[index]->name == "dimension" )
    {
      switch( ImageMatrices[index]->type )
      {
        case UINT:
          GetSize< unsigned int >(ImageMatrices[index]->data_ptr, size);
          break ;
        case SHORT:
          GetSize< short >(ImageMatrices[index]->data_ptr, size);
          break ;
        case USHORT:
          GetSize< unsigned short >(ImageMatrices[index]->data_ptr, size);
          break ;
        case UCHAR:
          GetSize< unsigned char >(ImageMatrices[index]->data_ptr, size);
          break ;
        default:
          return false;
      } // switch()

      std::cout<<"Dimension = ["<< size[0] << ", "<< size[1]<< " , "<< size[2]<<"]"<<std::endl; 
    } // if dimension

    // Spacing
    else if( ImageMatrices[index]->name == "voxel_size" )
    {
      switch( ImageMatrices[index]->type )
      {
        case DOUBLE:
          GetSpacing< double >(ImageMatrices[index]->data_ptr, spacing);
          break ;
        case FLOAT:
          GetSpacing< float >(ImageMatrices[index]->data_ptr, spacing);
          break ;
        default:
          return false;
      }
      std::cout<<"VoxelSize = ["<< spacing[0] << ", "<< spacing[1]<< " , "<< spacing[2]<<"]"<<std::endl;
    } // if spacing

    // z0
    else if( ImageMatrices[index]->name == "z0" )
    {
      z0 = *(float *)ImageMatrices[index]->data_ptr ;
      std::cout<<"z0 = "<<z0<<std::endl;
    }

    // images to write out
//    else if( ImageMatrices[index]->name == "gfa" ) // !!! any image needs to be after size & spacing
    // if vector contains name of current matrix -> write out image
    else if( std::find(ImagesToWriteOut.begin(), ImagesToWriteOut.end(), (std::string)ImageMatrices[index]->name) != ImagesToWriteOut.end() )
    {
      switch( ImageMatrices[index]->type )
      {
        case DOUBLE:
          WriteITKScalarImage< double >(ImageMatrices[index]->data_ptr, outputFolder + "/" + ImageMatrices[index]->name + ".nrrd", size, spacing);
          break ;
        case FLOAT:
          WriteITKScalarImage< float >(ImageMatrices[index]->data_ptr, outputFolder + "/" + ImageMatrices[index]->name + ".nrrd", size, spacing);
          break ;
        case SHORT:
          WriteITKScalarImage< short >(ImageMatrices[index]->data_ptr, outputFolder + "/" + ImageMatrices[index]->name + ".nrrd", size, spacing);
          break ;
        case UINT:
          WriteITKScalarImage< unsigned int >(ImageMatrices[index]->data_ptr, outputFolder + "/" + ImageMatrices[index]->name + ".nrrd", size, spacing);
          break ;
        default:
          return false;
      }
    } // if image to write out

    // odf_vertices and odf_faces
    else if( ImageMatrices[index]->name == "odf_vertices" || ImageMatrices[index]->name == "odf_faces")
    {
      switch( ImageMatrices[index]->type )
      {
        case DOUBLE:
          GetVertices< double         >(ImageMatrices[index]->data_ptr, ImageMatrices[index]->cols, outputFolder + "/" + ImageMatrices[index]->name + ".txt");
          break ;
        case FLOAT:
          GetVertices< float          >(ImageMatrices[index]->data_ptr, ImageMatrices[index]->cols, outputFolder + "/" + ImageMatrices[index]->name + ".txt");
          break ;
        case SHORT:
          GetVertices< short          >(ImageMatrices[index]->data_ptr, ImageMatrices[index]->cols, outputFolder + "/" + ImageMatrices[index]->name + ".txt");
          break ;
        case UINT:
          GetVertices< unsigned int   >(ImageMatrices[index]->data_ptr, ImageMatrices[index]->cols, outputFolder + "/" + ImageMatrices[index]->name + ".txt");
          break ;
        case USHORT:
          GetVertices< unsigned short >(ImageMatrices[index]->data_ptr, ImageMatrices[index]->cols, outputFolder + "/" + ImageMatrices[index]->name + ".txt");
          break ;
        default:
          return false;
      }
    } // if odf_vertices or odf_faces

  } // for all matrices


  return true;

} // bool writeITK()

  /////////////////////////////////////////
 //                MAIN                 //
/////////////////////////////////////////

int main (int argc, char* argv[])
{
  PARSE_ARGS;

/* Check input args */
  if( ODFfib == "" &&  ODFitk == "" )
  {
    std::cout<<"Error  : Please give an input ODF image."<<std::endl;
  }

  if( ODFfib != "" &&  ODFitk != "" )
  {
    std::cout<<"Warning: As both ITK and fib files have been given, the ITK image will be used."<<std::endl;
    ODFfib = ""; // so the ITK image is used
  }

  if( outputODF == "" )
  {
    if( ODFfib != "" )
    {
      outputODF = "./ODF.nrrd";
    }
    else
    {
      outputODF = "./ODF.fib.gz";
    }
    std::cout<<"Warning: No output image given, the output image will be: "<< outputODF <<std::endl;
  }

/* Convert image */
  if( ODFfib != "" ) // fib -> ITK
  {
    if( !writeITK( loadFib(ODFfib), outputODF ) )
    {
      return 1;
    }
  }
  else // ITK -> fib
  {
   if( ! writeFib( loadITK(ODFitk), outputODF ) )
    {
      return 1;
    }
  }

  return 0;

} // int main

/*

// WRITE .fib file

src/libs/dsi/odf_process.hpp
    -> 120: virtual void end(Voxel& voxel,MatFile& mat_writer) ->  mat_writer.add_matrix()
    -> 60: const unsigned int odf_block_size = 20000;
    -> struct OutputODF
    -> 75: OutputODF::init() -> ODF contain only voxels in mask
    -> std::vector<std::vector<float> > odf_data;  => ODF data stored in float

// .fib file

src/mainwindow.cpp: void MainWindow::loadFib(QString filename)
    -> std::auto_ptr<ODFModel> new_handle(new ODFModel);  -> new_handle = ptr on ODFModel
    -> new_handle->load_from_file( filename )

src/libs/tracking/tracking_model.hpp: class ODFModel
     -> ODFModel::load_from_file() -> fib_data.load_from_file()
     -> public:  FibData fib_data;

src/libs/tracking/fib_data.hpp: class FibData
     -> FibData::load_from_file() -> mat_reader.load_from_file() -> fib.add_data(mat_reader)
     -> public:  MatFile mat_reader;

src/libs/mat_file.hpp: class MatFile
     ===> MatFile::load_from_file()
     ===> MatFile::write_to_file()

src/libs/tracking/fib_data.hpp: class FiberDirection
     ===> FiberDirection::add_data()
     ===> FiberDirection contains ODFData

src/libs/tracking/fib_data.hpp: struct ODFData
     ===> ODFData contains odfs


// ODF vertices

src/libs/dsi/tessellated_icosahedron.hpp: class tessellated_icosahedron


// Name of .fib file

src/reconstruction/reconstruction_window.cpp: void reconstruction_window::doReconstruction()
    -> const char* msg = (const char*)reconstruction();

src/libs/dsi/dsi_interface_imp.cpp: const char* reconstruction()


// .src file

src/mainwindow.cpp: void MainWindow::loadSrc(QStringList filenames)
    ->  reconstruction_window* new_mdi = new reconstruction_window(filenames,this);

src/reconstruction/reconstruction_window.cpp: reconstruction_window::reconstruction_window()
    -> load_src(0);
    -> bool reconstruction_window::load_src(int index)
    -> handle->load_from_file(filenames[index].toLocal8Bit().begin())

src/reconstruction/reconstruction_window.h: class reconstruction_window:
    -> private:  std::auto_ptr<ImageModel> handle;

src/libs/dsi/image_model.hpp: struct ImageModel
    -> ImageModel.load_from_file() -> mat_reader->load_from_file()
    -> public:   std::auto_ptr<MatFile> mat_reader;

src/libs/mat_file.hpp: class MatFile
     ===> MatFile::load_from_file()
     ===> MatFile::write_to_file()

*/
